# Лабораторная работа №3

В этой лабораторной работе требуется написать решатель Судоку. Правила игры в Судоку достаточно простые, вот пояснения с [Википедии](https://ru.wikipedia.org/wiki/Судоку): 
> Игровое поле представляет собой квадрат размером 9×9, разделённый на меньшие квадраты со стороной в 3 клетки. Таким образом, всё игровое поле состоит из 81 клетки. В них уже в начале игры стоят некоторые числа (от 1 до 9), называемые подсказками. От игрока требуется заполнить свободные клетки цифрами от 1 до 9 так, чтобы в каждой строке, в каждом столбце и в каждом малом квадрате 3×3 каждая цифра встречалась бы **только один раз**.

Далее приведен пример Судоку и его решения:

![Пример решения Судоку](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)![Пример решения Судоку](https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)

Нам нужно каким-то образом хранить сам пазл. Для этого можно использовать обычные текстовые файлы, например, представленный выше пазл может выглядеть следующим образом:
```
53..7....
6..195...
.98....6.
8...6...3
4..8.3..1
7...2...6
.6....28.
...419..5
....8..79
```
где каждая точка соответствует пустой клетке, которую требуется заполнить числом.
 
Теперь нужно написать функцию для чтения пазла из файла (шаблон работы можно найти в репозитории). Назовем ее `read_sudoku()` и в качестве параметра будем передавать ей имя файла, в котором хранится пазл:
```python
def read_sudoku(filename):
    """ Прочитать Судоку из указанного файла """
    digits = [c for c in open(filename).read() if c in '123456789.']
    grid = group(digits, 9)
    return grid
```

**Задание №1**: На текущий момент вашей задачей является написать функцию `group()`, которая принимает пазл и размер доски `n`, а в качестве результата работы возвращает матрицу размера `n*n`:
```python
def group(values, n):
    """
    Сгруппировать значения values в список, состоящий из списков по n элементов

    >>> group([1,2,3,4], 2)
    [[1, 2], [3, 4]]
    >>> group([1,2,3,4,5,6,7,8,9], 3)
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    """
    pass
```

Чтобы убедиться в том, что вы верно написали функцию `group()` воспользуйтесь доктестом:

```sh
python -m doctest sudoku.py
```

Результат выполнения этой команды может быть следующим:
```sh
File "/Users/dementiy/Downloads/sudoku.py", line 13, in sudoku.group
Failed example:
    group([1,2,3,4], 2)
Expected:
    [[1, 2], [3, 4]]
Got nothing
**********************************************************************
File "/Users/dementiy/Downloads/sudoku.py", line 15, in sudoku.group
Failed example:
    group([1,2,3,4,5,6,7,8,9], 3)
Expected:
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Got nothing
**********************************************************************
4 items had failures:
   3 of   3 in sudoku.find_empty_positions
   3 of   3 in sudoku.get_col
   3 of   3 in sudoku.get_row
   2 of   2 in sudoku.group
***Test Failed*** 11 failures
```

На текущий момент нас интересует только функция `group()` и из двух тестов она не прошла ни один. В начале вывода показано, какой результат ожидался (`Expected`), а какой получили (`Got`). Если вы написали функцию верно, то эти сообщения исчезнут, но останутся сообщения для пока еще не написанных функций.


Если вы перестали видеть сообщения с ошибками для функции `group()`, то давайте посмотрим как работает функция `read_sudoku()`. Запустите программу следующим образом (все пазлы также в репозитории):

```python
$ python -i sudoku.py
>>> grid = read_sudoku('puzzle1.txt')
>>> from pprint import pprint as pp
>>> pp(grid)
[['5', '3', '.', '.', '7', '.', '.', '.', '.'], 
 ['6', '.', '.', '1', '9', '5', '.', '.', '.'], 
 ['.', '9', '8', '.', '.', '.', '.', '6', '.'], 
 ['8', '.', '.', '.', '6', '.', '.', '.', '3'], 
 ['4', '.', '.', '8', '.', '3', '.', '.', '1'], 
 ['7', '.', '.', '.', '2', '.', '.', '.', '6'], 
 ['.', '6', '.', '.', '.', '.', '2', '8', '.'], 
 ['.', '.', '.', '4', '1', '9', '.', '.', '5'], 
 ['.', '.', '.', '.', '8', '.', '.', '7', '9']]
```

Как видите вывод содержимого пазла (`grid`) не очень нагляден, поэтому для вас написана функция `display()`, которая выводит пазл в более человеко-наглядной форме.

```python
>>> display(grid)
5 3 . |. 7 . |. . . 
6 . . |1 9 5 |. . . 
. 9 8 |. . . |. 6 . 
------+------+------
8 . . |. 6 . |. . 3 
4 . . |8 . 3 |. . 1 
7 . . |. 2 . |. . 6 
------+------+------
. 6 . |. . . |2 8 . 
. . . |4 1 9 |. . 5 
. . . |. 8 . |. 7 9 
```

**Задание №2**: Так как при решении Судоку ставится условия, что значения не могут повторяться ни в строке, ни в столбце, ни в квадрате, то следовательно нам эти значения нужно получить. Для этого от вас требуется написать три функции `get_row()`, `get_col()` и `get_block()`, каждая из которых принимает два аргумента, пазл (`values`) и позицию (`pos`), для которой мы пытаемся найти верное число.

```python
def get_row(values, pos):
    """ Возвращает все значения для номера строки, указанной в pos

    >>> get_row([['1', '2', '.'], ['4', '5', '6'], ['7', '8', '9']], (0, 0))
    ['1', '2', '.']
    >>> get_row([['1', '2', '3'], ['4', '.', '6'], ['7', '8', '9']], (1, 0))
    ['4', '.', '6']
    >>> get_row([['1', '2', '3'], ['4', '5', '6'], ['.', '8', '9']], (2, 0))
    ['.', '8', '9']
    """
    pass


def get_col(values, pos):
    """ Возвращает все значения для номера столбца, указанного в pos 

    >>> get_col([['1', '2', '.'], ['4', '5', '6'], ['7', '8', '9']], (0, 0))
    ['1', '4', '7']
    >>> get_col([['1', '2', '3'], ['4', '.', '6'], ['7', '8', '9']], (0, 1))
    ['2', '5', '8']
    >>> get_col([['1', '2', '3'], ['4', '5', '6'], ['.', '8', '9']], (0, 2))
    ['3', '6', '9']
    """
    pass


def get_block(values, pos):
    """ Возвращает все значения из квадрата, в который попадает позиция pos """
    pass
```

Разберемся с тем, как представлена позиция в программе. Каждая позиция однозначно определяется номером строки и номером столбца, поэтому для ее представления удобно использовать кортеж. Напомним, что кортеж это неизменяемый список. Позиция создается следующим образом:
```python
>>> pos = (0, 0)
>>> row, col = pos
>>> row
0
>>> col
0
```
 
Для функций `get_row()` и `get_col()` приведены доктесты, но они предназначены для доски размером `3*3`. У нас же доска `9*9`. Вы можете написать эти функции так, чтобы их можно было использовать для доски любого размера, а можете написать только для доски размером `9*9`, но тогда вы всегда будете получать ошибку в доктестах. Функция `get_block()` возвращает все значения из квадрата, в который попадает позиция `pos` (всего `9` квадратов размером `3*3`).


**Задание №3.1**: Давайте наконец перейдем к решению самого Судоку. В шаблоне вы найдете функцию `solve()`, которая принимает один аргумент - пазл, а возвращает заполненную значениями доску:

```python
def solve(grid):
    """ Решение пазла, заданного в grid """
    """ Как решать Судоку?
        1. Найти свободную позицию
        2. Найти все возможные значения, которые могут находиться на этой позиции
        3. Для каждого возможного значения:
            3.1. Поместить это значение на эту позицию
            3.2. Продолжить решать оставшуюся часть пазла
    """
    pass
```

В комментарии приведен алгоритм решения Судоку. Обратите внимание, что он рекурсивный. Решение Судоку очень похоже на задачу о возможных комбинациях:

```python
def permutations(L, result):
    if len(L) == 0:
        print(result)
    else:
        for i in range(len(L)):
            permutations(L[0:i] + L[i+1:], result + [L[i]])
```

Каждый раз мы удерживаем один элемент и перебираем все остальные. В Судоку все происходит точно также, сначала мы подставляем одно из возможных значений (пункт 2) для свободной позиции (пункт 1) и перебираем все остальные (пункт 3.2), то есть решаем более простую задачу. Например, вот простейшее "Судоку" (это не совсем Судоку конечно), которое мы можем заполнять значениями 1 или 2:

```
1.
.1
```

Находим первую свободную позицию (это окажется `(0, 1)`), затем значения которые можем на нее поставить (в данном случае только 2), вставляем это значение на указанную позицию и продолжаем решать уже более простое Судоку:

```
12
.1
```

И так продолжаем, пока не заполним все пустые клетки. В конце мы должны получить решение Судоку.

Не забудьте про базовые случаи для выхода из рекурсии, подумайте над вопросами:
* Всегда ли есть свободная позиция?
* Всегда ли есть возможные значения?
 
**Задание №3.2**: Нам нужно находить свободные позиции (то есть те, на которых стоит `.` - точка). Для этого требуется написать функцию `find_empty_positons()`, которая принимает один аргумент - пазл и возвращает первую попавшуюся свободную позицию:
```python
def find_empty_positions(grid):
    """ Найти первую свободную позицию в пазле 

    >>> find_empty_positions([['1', '2', '.'], ['4', '5', '6'], ['7', '8', '9']])
    (0, 2)
    >>> find_empty_positions([['1', '2', '3'], ['4', '.', '6'], ['7', '8', '9']])
    (1, 1)
    >>> find_empty_positions([['1', '2', '3'], ['4', '5', '6'], ['.', '8', '9']])
    (2, 0)
    """
    pass 
```

**Задание №3.3**: Кроме поиска свободных позиций, также необходимо искать значения, которые на эту позицию можно поставить:
```python
def find_possible_values(grid, pos):
    """ Вернуть все возможные значения для указанной позиции """
    pass
```

Помните, что всего значений, которые мы можем поставить на указанную позицию, ровно `9`, это числа `1,2,3,4,5,6,7,8,9`. Но не каждое из этих чисел мы можем использовать (см. правила Судоку). В этой функции вы можете пользоваться написанными ранее функциями `get_row()`, `get_col()`, `get_block()`.
 
Когда вы закончите работать над функциями, то выполните следующие команды:
```python
$ python -i sudoku.py
>>> grid = read_sudoku('puzzle1.txt')
>>> display(grid)
5 3 . |. 7 . |. . . 
6 . . |1 9 5 |. . . 
. 9 8 |. . . |. 6 . 
------+------+------
8 . . |. 6 . |. . 3 
4 . . |8 . 3 |. . 1 
7 . . |. 2 . |. . 6 
------+------+------
. 6 . |. . . |2 8 . 
. . . |4 1 9 |. . 5 
. . . |. 8 . |. 7 9

>>> solution = solve(grid)
>>> display(solution)
5 3 4 |6 7 8 |9 1 2 
6 7 2 |1 9 5 |3 4 8 
1 9 8 |3 4 2 |5 6 7 
------+------+------
8 5 9 |7 6 1 |4 2 3 
4 2 6 |8 5 3 |7 9 1 
7 1 3 |9 2 4 |8 5 6 
------+------+------
9 6 1 |5 3 7 |2 8 4 
2 8 7 |4 1 9 |6 3 5 
3 4 5 |2 8 6 |1 7 9 
```

**Задание №4**: Мы получили решение, но является ли оно верным? Давайте напишем функцию `check_solution()`, которая проверяет наше решение:
```python
def check_solution(solution):
    """ Если решение solution верно, то вернуть True, в противном случае False """
    pass
```
Решение оказывается верным, если ни в одной строке, ни в одном столбце, ни в квадрате не повторяются значения:
```python
>>> check_solution(solution)
True
```
 
Когда вы закончите работать над этой функцией, то запустите программу следующим образом:
```sh
$ python sudoku.py
...
Solution is correct
...
Solution is correct
...
Solution is correct
```

**Примечание**: Вывод пазлов и их решений опущен.
Если вы встретили сообщение `Ooops`, то значит, что одно или все ваши решения оказались не верны. Если же вы уверены в своем решении, то проверьте корректность функции `check_solution()`.