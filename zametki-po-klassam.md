# Заметки по ООП в Python

Это краткий конспект по классам, который не является исчерпывающим руководством. Также я не даю определений таким понятиям как ООП, класс, объект и т.п. Все эти определения вы можете легко найти в сети.

### Процедурный подход

Представьте, что вы пишите веб-сервис и перед вами встала следующая задача: "_Как представить пользователя системы в программе?_". Давайте договоримся, что у каждого пользователя должны быть следующие атрибуты:

* имя \(username\)
* адрес электронной почты \(email\)
* пароль \(password\)

Можно представить пользователя в виде нескольких переменных:

```py
username = 'bob'
email = 'bob@example.com'
password = 'foobar'
```

У такого подхода есть несколько недостатков:

1. Мы пониманием, что переменные логически должны быть связаны между собой, но мы эту связь никак не показали. Другими словами, переменная `username`  может содержать имя одного пользователя, `email` относиться ко второму пользователю, а `password` к третьему.
2. Если нам необходимо одновременно взаимодействовать с несколькими пользователями, то для каждого из них нужно создавать по три таких переменных.

Как показать, что существует логическая связь между этими переменными? Мы можем использовать любую подходящую структуру: список, словарь, кортеж, именованный кортеж. Как пример будем использовать кортеж \(именованный кортеж, т.е. [`namedtuple`](https://www.blog.pythonlibrary.org/2016/03/15/python-201-namedtuple/), было бы использовать нечестно\):

```py
# Представление отдельно взятого пользователя
user = ('bob', 'bob@example.com', 'foobar') 

# А так мы теперь можем представить список пользователей
users_list = [
    ('bob', 'bob@example.com', 'foobar'),
    ('joe', 'joe@example.com', 'barfoo'),
]
```

Таким образом, объединив несколько значений \(имя, адрес электронной почты и пароль\) в контейнер, мы попытались показать, что существует логическая связь между этими значениями.

Теперь напишем простую функцию, которая возвращает имя пользователя:

```py
def get_username(user):
    return user[0]


>>> get_username(user)
'bob'
```

Так как пользователь представлен кортежем из трех значений, то мы возвращаем элемент по индексу 0, который соответствует имени.

Представьте, что у некоторых пользователей мы решили сохранять их идентификационный номер `id`, который уникален для каждого пользователя. И этот идентификатор будет нулевым элементом нашего кортежа:

```py
user = (1, 'bob', 'bob@example.com', 'foobar')
```

Очевидно, что функция `get_username` не будет возвращать имя пользователя для кортежа с такой структурой \(если бы мы использовали словарь, то такой проблемы не было бы\). Мы можем написать еще одну функцию, которая будет работать с кортежами такой структуры:

```py
def get_username_for_users_with_id(user):
    return user[1]


>>> get_username_for_users_with_id(user)
'bob'
```

У нас теперь есть две функции для пользователей с разной структурой, что является избыточным решением, но главная проблема заключается в том, что мы не показали логическую связь между данными о пользователе и той функцией, которая должна с ними работать.

В решении этой проблемы нам могут помочь классы.

### Создание простого класса

Начнем с создания простого класса:

```py
class User:
    pass
```



```py
u = User()
```



```py
u.username = 'bob'
u.password = 'bob@example.com'
u.email = 'foobar'
```



```py
>>> hasattr(u, 'created_at')
False
>>> hasattr(u, 'username')
True

>>> getattr(u, 'created_at')
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    getattr(u, 'created_at')
AttributeError: 'User' object has no attribute 'created_at'

import datetime
>>> getattr(u, 'created_at', datetime.datetime.now())
datetime.datetime(2017, 4, 11, 16, 45, 36, 757869)

>>> setattr(u, 'created_at', datetime.datetime.now())
datetime.datetime(2017, 4, 11, 16, 45, 36, 757869)
```



```py
u = User()
attrs = {'username': bob', 'email': 'bob@example.com', 'password': 'foobar'}
for k, v in attrs.items():
    setattr(u, k, v)
```



```py
def get_username(user):
    return user.username

>>> u.get_username = get_username
>>> u.get_username(u)
'bob'
```



```py
>>> from types import MethodType
>>> u.get_username = MethodType(get_username, u)
>>> u.get_username()
'bob'
```



```py
class User:
    def __init__(self, username, email, password):
        self.username = username
        self.email = email
        self.password = password
    
    def get_username(self):
        return self.username
```



```py
>>> u = User('bob', 'bob@example.com', 'foobar')
>>> u.email
'bob@example.com'
>>> u.get_username()
'bob'
```



### "Приватные" поля класса



### Свойства \(property\)



### Методы класса \(@classmethod и @staticmethod\)



### Наследование



### Множественное наследование и полиморфизм



### Метаклассы



### Абстрактные классы



