# Заметки по ООП в Python

Это краткий конспект по классам, который не является исчерпывающим руководством. Также я не даю определений таким понятиям как ООП, класс, объект и т.п. Все эти определения вы можете легко найти в сети.

### Проблема 

Представьте, что вы пишите веб-сервис и перед вами встала следующая задача: "_Как представить пользователя системы в программе?_". Давайте договоримся, что у каждого пользователя должны быть следующие атрибуты:

* имя \(username\)
* адрес электронной почты \(email\)
* пароль \(password\)

Можно представить пользователя в виде нескольких переменных:

```py
username = 'bob'
email = 'bob@example.com'
password = 'foobar'
```

У такого подхода есть несколько недостатков:

1. Мы пониманием, что переменные логически должны быть связаны между собой, но мы эту связь никак не показали. Другими словами, переменная `username`  может содержать имя одного пользователя, `email` относиться ко второму пользователю, а `password` к третьему.
2. Если нам необходимо одновременно взаимодействовать с несколькими пользователями, то для каждого из них нужно создавать по три таких переменных.

Как показать, что существует логическая связь между этими переменными? Мы можем использовать любую подходящую структуру: список, словарь, кортеж, именованный кортеж. Как пример будем использовать кортеж \(именованный кортеж, т.е. `namedtuple`, было бы использовать нечестно\):

```py
# Представление отдельно взятого пользователя
user = ('bob', 'bob@example.com', 'foobar') 

# А так мы теперь можем представить список пользователей
users_list = [
    ('bob', 'bob@example.com', 'foobar'),
    ('joe', 'joe@example.com', 'barfoo'),
]
```

Таким образом, объединив несколько значений \(имя, адрес электронной почты и пароль\) в контейнер, мы попытались показать, что существует логическая связь между этими значениями.

Теперь напишем простую функцию, которая возвращает имя пользователя:

```py
def get_username(user):
    return user[0]


>>> get_username(user)
'bob'
```

Так как пользователь представлен кортежем из трех значений, то мы возвращаем элемент по индексу 0, который соответствует имени.

Представьте, что у некоторых пользователей мы решили сохранять их идентификационный номер `id`, который уникален для каждого пользователя. И этот идентификатор будет нулевым элементом нашего кортежа:

```py
user = (1, 'bob', 'bob@example.com', 'foobar')
```

 Очевидно, что функция `get_username` не будет возвращать имя пользователя для кортежа с такой структурой \(если бы мы использовали словарь, то такой проблемы не было бы\). Мы можем написать еще одну функцию, которая будет работать с кортежами такой структуры:

```py
def get_username_for_users_with_id(user):
    return user[1]


>>> get_username_for_users_with_id(user)
'bob'
```

У нас теперь есть две функции для пользователей с разной структурой, что является избыточным решением, но главная проблема заключается в том, что мы не показали логическую связь между данными о пользователе и той функцией, которая должна с ними работать.

В решении этой проблемы нам могут помочь классы.

### Создание простого класса



### "Приватные" поля класса

### Методы класса \(@classmethod и @staticmethod\)

### Свойства \(property\)

### Наследование

### Множественное наследование и полиморфизм

### Метаклассы



